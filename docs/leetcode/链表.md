# 链表

## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

- 题目描述

给你两个非空的链表，表示两个整数并且两个整数是逆序的，将两个整数求和，并返回求和后的链表

- 示例

```txt
输入：243，564
输出：708
解释：342 + 465 = 807
```

- 思路

1. 新构建一个链表用来存放相加的结果，初始化一个进位变量为 0
2. 遍历两个链表，计算当前节点的和，并且加上进位，并且更新进位（条件是大于10）

- 代码

```py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1, l2):
        # 定义一个新的链表
        dummy_head = ListNode(0)
        cur = dummy_head
        # 进位
        carry = 0
        # l1 或者 l2 都不为空，进入循环
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            # 两个链表的值相加，并且加上进位
            total = x + y + carry
            # 计算进位
            carry = total // 10
            # 链表新的节点赋值
            cur.next = ListNode(total % 10)
            # 链接后移，往后走
            cur = cur.next

            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        if carry > 0:
            cur.next = ListNode(carry)
        return dummy_head.next
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

- 题目描述

给出一个链表，删除链表的倒数第 N 个节点

- 示例

```txt
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

```

- 思路

1. 如果知道链表的长度 L ，那么要删除的节点就是 L - n + 1
2. 所以第一遍遍历计算出长度
3. 第二遍遍历走到 L - n + 1 时，将 next 指针指到下一位就好了

- 代码

```py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int):
        def get_length(head):
            length = 0
            while head:
                length += 1
                head = head.next
            return length

        dummy = ListNode(0, head)
        length = get_length(head)

        cur = dummy
        for i in range(1, length - n + 1):
            cur = cur.next
        cur.next = cur.next.next
        return dummy.next
```

## [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

描述

```txt
给你一个链表的头节点 head ，判断链表中是否有环
如果链表中有某个节点可以通过连续跟踪 next 指针再次到达，则链表中存在环
```

示例

![141. 环形链表](/141环形链表.png)

思路

1. 快慢指针
2. 如果有环，则两个指针会相遇，返回 True

代码

```py
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return False
        slow = head
        fast = head.next
        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
```

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

描述

```txt
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null
```

示例

![142. 环形链表 II](/142环形链表.png)

思路

1. 同样的快慢指针
2. 快慢指针都指向头节点，如果快指针走到结尾，表示没有环，并返回 None
3. 如果快慢指针相遇，则有环，这个时候将快指针重新指向表头，并和慢指针相同步伐走，直到相遇，就是环的起点

代码

```py
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return None
        slow = fast = head
        # 判断有没有环
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        # 如果快的走到结尾，表示没环
        if not fast or not fast.next:
            return None
        # 将快指针重新指向头结点，相同的步伐走
        fast = head
        while fast != slow:
            slow = slow.next
            fast = fast.next
        return fast
```

## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

- 描述

设计一个满足 LRU 的数据结构， LRU ：最近最少使用缓存

- 示例

```txt
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

- 思路

1. 通过哈希和双向链表来实现
2. 每次访问，先在哈希中查找，如果存在则表示命中缓存，将节点移动到表头
3. 如果不存在，表示未命中，将节点插入到表头，同时如果缓存满的话，需要删除表尾节点

- 代码

```py
class Node:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRU:
    def __init__(self, cap):
        self.cache = dict()
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.cap = cap

    def get(self, key):
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self.remove(node)
        self.add_to_head(node)
        return node.value
    
    def put(self, key, value):
        if key in self.cache:
            self.remove(self.cache[key])
        node = Node(key, value)
        self.cache[key] = node
        self.add_to_head(node)
        if len(self.cache) > self.cap:
            last_node = self.tail.prev
            self.remove(last_node)
            del self.cache[last_node.key]


    def add_to_head(self, node):
        next_node = self.head.next
        node.next = next_node
        node.prev = self.head
        self.head.next = node
        next_node.prev = node
    
    def remove(self, node):
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node
```

## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

- 描述

给一个链表的头节点，返回排序后的链表，排序是升序

- 示例

![148. 排序链表](/148排序链表.png)

- 思路

1. 使用归并排序，先找到链表的中间，分成两半
2. 递归地对两个链表排序
3. 合并两个有序的链表

- 代码

```py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # 使用快慢指针找到链表的中间
        fast, slow = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next
        slow.next = None
    

        left = self.sortList(head)
        right = self.sortList(mid)

        return self.merge(left, right)
    
    def merge(self, l1, l2):
        dummy_head = ListNode()
        cur = dummy_head

        while l1 and l2:
            if l1.val < l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy_head.next
```

## [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

- 描述

```txt
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点

如果两个链表不存在相交节点，返回 null
```

- 示例

![160.相交链表](/160.相交链表.png)

- 思路

1. 双指针，直到两指针相遇

- 代码

```py
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def getIntersectionNode(self, headA, headB):
        if not headA or not headB:
            return None

        p1 = headA
        p2 = headB
        while p1 != p2:
            p1 = p1.next if p1 else headB
            p2 = p2.next if p2 else headA
        return p1
```
