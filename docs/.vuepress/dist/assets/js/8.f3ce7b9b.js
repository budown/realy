(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{282:function(t,a,n){"use strict";n.r(a);var s=n(14),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),a("h2",{attrs:{id:"进程线程协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程线程协程"}},[t._v("#")]),t._v(" 进程线程协程")]),t._v(" "),a("h2",{attrs:{id:"从输入url到浏览器页面显示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到浏览器页面显示"}},[t._v("#")]),t._v(" 从输入URL到浏览器页面显示")]),t._v(" "),a("p",[t._v("这个问题总是在面试的时候被问到，其实就是八股文，但是可以由八股往深了去聊，还是能考验基础的")]),t._v(" "),a("h3",{attrs:{id:"概括来讲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概括来讲"}},[t._v("#")]),t._v(" 概括来讲")]),t._v(" "),a("p",[t._v("1、URL 解析\n2、DNS 域名解析\n3、TCP 建立连接\n4、发送 HTTP 请求\n5、服务器处理 HTTP 请求并响应 HTTP 请求\n6、接收 HTTP 响应并下载资源然后渲染页面\n7、TCP 关闭连接")]),t._v(" "),a("p",[t._v("我们以 www.google.com 为例子具体来说")]),t._v(" "),a("h3",{attrs:{id:"dns-域名解析阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns-域名解析阶段"}},[t._v("#")]),t._v(" DNS 域名解析阶段")]),t._v(" "),a("p",[t._v("1、浏览器会先看自身有没有这个域名的缓存，如果有就直接返回，没有就去问操作系统\n2、操作系统中会对 DNS 解析结果有缓存，如果有就直接返回，如果没有就从 /etc/hosts 文件中找，有就返回，没有就真正开始去递归的问\n3、客户端发出请求，问 www.google.com 的 IP 是啥，发送给本地的 DNS 服务器，也就是本机填写的 DNS 服务器地址，一般是在 /etc/resolv.conf 配置文件中\n4、本地 DNS 收到请求后，先查询缓存中是否有对应的解析的缓存，如果没有，则去问根域名服务器\n5、根域名服务器收到请求后，发现后缀是 .com，则返回 .com 顶级域名服务器的地址，让去问它\n6、本地 DNS 收到顶级域名服务器的地址后，发出请求，问 www.google.com 的 IP 地址是啥，发送给顶级域名服务器\n7、顶级域名服务器收到请求后，返回 google.com 这个权威域的服务器地址，让去问它\n8、本地 DNS 收到权威域名服务器的地址后，发出请求，问 www.google.com 的 IP 地址是啥，发送给权威域名服务器\n9、权威域名服务器收到请求后，查到并返回对应的 IP 地址给本地 DNS\n10、本地 DNS 收到返回，发送给客户端，并本地缓存")]),t._v(" "),a("h3",{attrs:{id:"tcp-建立连接阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-建立连接阶段"}},[t._v("#")]),t._v(" TCP 建立连接阶段")]),t._v(" "),a("p",[t._v("1、开始的时候，服务器端会监听某个端口，处于 LISTEN 状态\n2、客户端主动发起建立连接发送 SYN ，状态是 SYN_SENT\n3、服务器端收到请求，返回 SYN+ACK ，状态是 SYN_REVD\n4、之后客户端再发送 ACK ，状态是 ESTABLISHED ，服务端收到 ACK ，状态也是 ESTABLISHED")]),t._v(" "),a("p",[t._v("发送 HTTP 请求")]),t._v(" "),a("p",[t._v("1、HTTP 的请求报文包含：请求行，请求头，空行，请求正文\n2、请求行：请求的方式 GET/POST 等，请求的资源名称 URL 以及使用的 HTTP 协议的版本\n3、请求头：描述客户端请求哪个主机及其端口，已经客户端的一些环境信息等\n4、空行： \\r\\n")]),t._v(" "),a("h3",{attrs:{id:"服务端响应-http-请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端响应-http-请求"}},[t._v("#")]),t._v(" 服务端响应 HTTP 请求")]),t._v(" "),a("p",[t._v("1、HTTP 响应包含：状态行、响应头、空格、消息体\n2、状态行：协议版本、状态码、状态码描述\n3、响应头：用于描述服务器的基本信息，以及客户端如何处理数据\n4、空格： CRLF (\\r\\n) 分割\n5、消息体：服务器返回给客户端的数据")]),t._v(" "),a("h3",{attrs:{id:"关闭-tcp-连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关闭-tcp-连接"}},[t._v("#")]),t._v(" 关闭 TCP 连接")]),t._v(" "),a("p",[t._v("1、客户端发送 FIN 报文，状态变为 TIME_WAIT_1\n2、服务端收到报文后，向客户端发送 ACK 应答报文，状态变为 CLOSE_WAIT\n3、客户端收到 ACK 应答报文后，状态变为 TIME_WAIT_2\n4、服务端也向客户端发送 FIN 报文，状态变为 LAST_ACK\n5、客户端收到服务端的 FIN 报文，应答 ACK ，状态变为 TIME_WAIT\n6、服务端收到 ACK 应答报文后，状态进入 CLOSE ，服务端关闭连接\n7、客户端在 2MSL 时间后，状态进入 CLOSE ，客户端关闭连接")]),t._v(" "),a("p",[t._v("所以为啥关闭 TCP 连接需要4次握手")]),t._v(" "),a("p",[t._v("1、客户端向服务端发送 FIN 报文时，仅仅表示客户端不再发送数据了但是还能接收数据\n2、服务端收到客户端的 FIN 报文时，回一个 ACK 应答报文，而这个时候服务端可能还有数据需要处理和发送\n3、等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接")])])}),[],!1,null,null,null);a.default=r.exports}}]);