# 树

## 114. 二叉树展开为链表

题目地址

https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/

题目描述

```txt
给你二叉树的根结点 root ，请你将它展开为一个单链表

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null
展开后的单链表应该与二叉树 先序遍历 顺序相同
```

示例

```txt
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]

输入：root = []
输出：[]

输入：root = [0]
输出：[0]
```

思路

1、先将二叉树进行前序遍历
2、更新前序遍历结果中每个节点的左右节点信息，左为null，右边是下一个节点

代码

```py
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        preorderList=[]
        def preorder(root):
            if root:
                preorderList.append(root)
                preorder(root.left)
                preorder(root.right)

        preorder(root)
        for i in range(1, len(preorderList)):
            pre, cur = preorderList[i-1], preorderList[i]
            pre.left = None
            pre.right = cur
```

## 105. 从前序与中序遍历序列构造二叉树

题目地址

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

题目描述

```txt
给定两个整数数组 preorder 和 inorder
其中 preorder 是二叉树的先序遍历
inorder 是同一棵树的中序遍历
请构造二叉树并返回其根节点
```

示例

```txt
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]

输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

思路

1、前序遍历：根左右，中序遍历：左根右
2、前序遍历：[根，[左子树前序遍历结果]，[右子树前序遍历结果]]
3、中序遍历：[[左子树中序遍历结果]，根，[右子树中序遍历结果]]
4、在前序遍历的列表中，第一个就是根节点
5、在中序遍历的列表中，找到根节点，根节点左边就是左子树的中序遍历，右边就是右子树的中序遍历

```py
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
class Solution:
    def buildTree(self, preorder, inorder):
        if not preorder or not inorder:
            return None
        # 前序的第一个就是根节点
        root_val = preorder[0]
        # 把根节点建立起来
        root = TreeNode(root_val)
        # 找到中序遍历中根节点的位置
        root_index = inorder.index(root_val)
        # 递归构造左子树，前序数组的左边部分，和中序数组的左边部分
        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])
        # 递归构造右子树，前序数组的右边部分，和中序数组的右边部分
        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])
        return root
```
